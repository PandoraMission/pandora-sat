{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":""},{"location":"#pandorasat","title":"PandoraSat","text":"<p>This Python package contains metadata for Pandora and basic functions describing things such as detector sensitivity and zeropoint estimation.</p>"},{"location":"#installation","title":"Installation","text":"<p>To install you can use</p> <pre><code>pip install pandorasat --upgrade\n</code></pre> <p>You should update your package often, as we frequently put out new versions with updated Current Best Estimates, and some limited new functionality. Check your version number using</p> <pre><code>import pandorasat as ps\nps.__version__\n</code></pre>"},{"location":"#pandora-information","title":"Pandora Information","text":"<p>This repository helps you understand what the Pandora SmallSat will be capabale of.</p>"},{"location":"#example-usage","title":"Example Usage","text":"<p>Below is an example usage of some of the functionality in this package. In general, this package will allow you to get metadata from specific subsystems of Pandora.</p> <pre><code>from pandorasat import VisibleDetector, NIRDetector\nvisda = VisibleDetector()\nvisda.pixel_scale\nvisda.pixel_size\n\nnirda = NIRDetector()\nnirda.plot_sensitivity()\n</code></pre> <p>See our API documentation for full details on the metadata available in this package.</p> <p>To update any of the values or functions contained within <code>pandora-sat</code> due to new testing, commissioning, etc., please open a pull request. Update the relevant values or functions on your branch and then the updates will be reviewed prior to being merged into the main branch of <code>pandora-sat</code>.</p>"},{"location":"#configuration-parameters","title":"Configuration Parameters","text":"<p>Below is a table of all the configuration parameters in <code>pandorapsf</code> and their current defaults</p> (section, key) Description ('SETTINGS', 'data_dir') Where data will be stored for the package. This includes ~150Mb of phoneix model files which will be downloaded. ('SETTINGS', 'log_level') Default level for the logger. Change this to make the tool more or less verbose by default."},{"location":"hardware/","title":"Documentation for <code>Hardware</code>","text":"<p>The <code>Hardware</code> class contains basic information about Pandora's optics.</p>"},{"location":"hardware/#api-documentation-for-pandorasathardware","title":"API Documentation for <code>pandorasat.Hardware</code>","text":"<p>Holds basic metadata on the optics of Pandora</p> <p>Parameters:</p> Name Type Description Default <code>mirror_diameter</code> <code>float</code> <p>Diameter of the Pandora mirror</p> required"},{"location":"hardware/#pandorasat.hardware.Hardware.mirror_diameter","title":"<code>mirror_diameter</code>  <code>property</code>","text":"<p>Diameter of Pandora's mirror. This should be the effective diameter of the primary, removing the secondary diameter.</p>"},{"location":"hardware/#pandorasat.hardware.Hardware.primary_mirror_effective_diameter","title":"<code>primary_mirror_effective_diameter</code>  <code>property</code>","text":"<p>Diameter of Pandora's primary mirror that will reflect light.</p>"},{"location":"hardware/#pandorasat.hardware.Hardware.secondary_mirror_physical_diameter","title":"<code>secondary_mirror_physical_diameter</code>  <code>property</code>","text":"<p>Diameter of Pandora's secondary mirror that will block light.</p>"},{"location":"intro-to-pandorasat/","title":"Introduction","text":"<p><code>pandora-sat</code> is a respository for information about the Pandora spacecraft, its detectors, and its orbit. It holds information on the spacecraft that is independent of pointing and target. This package is continually updated with the most current information on Pandora.</p> In\u00a0[1]: Copied! <pre>import pandorasat as ps\nimport matplotlib.pyplot as plt\nimport numpy as np\nimport astropy.units as u\nplt.style.use(ps.PANDORASTYLE)\n</pre> import pandorasat as ps import matplotlib.pyplot as plt import numpy as np import astropy.units as u plt.style.use(ps.PANDORASTYLE) <p>You can initialize the observatory using</p> In\u00a0[2]: Copied! <pre>p = ps.PandoraSat()\n</pre> p = ps.PandoraSat() <p>This object acts as a container of the different observatory components: the visible detector (VISDA), the NIR detector (NIRDA), the optics and hardware of the spacecraft (Hardware), and the orbit of the spacecraft (Orbit). You can access each of these components via the following</p> In\u00a0[3]: Copied! <pre>visda = p.VISDA\nnirda = p.NIRDA\nhardware = p.Hardware\norbit = p.Orbit\n</pre> visda = p.VISDA nirda = p.NIRDA hardware = p.Hardware orbit = p.Orbit <p>Each of these objects contains information on each of their respective components. Many of these are very useful quantities such as the pixel_scale of the detectors or the period of the orbit. For example, we can take a look at some of this info using</p> In\u00a0[4]: Copied! <pre># This will print the pixel scale of the NIR detector\nprint(p.NIRDA.pixel_size)\n\n# This will print the number of columns of the visible detector\nprint(p.VISDA.naxis1)\n# and the number of rows of the visible detector\nprint(p.VISDA.naxis2)\n\n# This will print the mirror diameter of Pandora's mirror\nprint(p.Hardware.mirror_diameter)\n\n# This will print Pandora's orbital period\nprint(p.Orbit.period)\n</pre> # This will print the pixel scale of the NIR detector print(p.NIRDA.pixel_size)  # This will print the number of columns of the visible detector print(p.VISDA.naxis1) # and the number of rows of the visible detector print(p.VISDA.naxis2)  # This will print the mirror diameter of Pandora's mirror print(p.Hardware.mirror_diameter)  # This will print Pandora's orbital period print(p.Orbit.period) <pre>18.0 um / pix\n2048.0 pix\n2048.0 pix\n0.4264141179651537 m\n90.0 min\n</pre> <p>In addition to standalone values, <code>pandora-sat</code> contains useful functions that do thing such as describe the sensitivity of the detectors, convert between magnitude and flux, or estimate the throughput of a detector. Say we wanted to fetch the sensitivity of the NIR and Visible detectors then plot them for easy viewing. We would do that as follows</p> In\u00a0[5]: Copied! <pre>w = np.arange(0.1, 2, 0.01) * u.micron\nfig, ax = plt.subplots()\nax.plot(w, nirda.sensitivity(w), label='NIRDA', c='k', ls='-')\nax.plot(w, visda.sensitivity(w), label='VISDA', c='k', ls='--')\nax.set(xlabel='Wavelength [microns]', ylabel=f\"Sensitivity [{nirda.sensitivity(w).unit.to_string('latex')}]\")\nplt.legend()\n</pre> w = np.arange(0.1, 2, 0.01) * u.micron fig, ax = plt.subplots() ax.plot(w, nirda.sensitivity(w), label='NIRDA', c='k', ls='-') ax.plot(w, visda.sensitivity(w), label='VISDA', c='k', ls='--') ax.set(xlabel='Wavelength [microns]', ylabel=f\"Sensitivity [{nirda.sensitivity(w).unit.to_string('latex')}]\") plt.legend() Out[5]: <pre>&lt;matplotlib.legend.Legend at 0x13cfe0100&gt;</pre> <p>Likewise, we can plot the throughput of the two detectors across the same wavelength regime like so</p> In\u00a0[6]: Copied! <pre>fig, ax = plt.subplots()\nax.plot(w, nirda.throughput(w), label='NIRDA', c='k', ls='-')\nax.plot(w, visda.throughput(w), label='VISDA', c='k', ls='--')\nax.set(xlabel='Wavelength [microns]', ylabel=f\"Throughput [Fractional]\")\nplt.legend()\n</pre> fig, ax = plt.subplots() ax.plot(w, nirda.throughput(w), label='NIRDA', c='k', ls='-') ax.plot(w, visda.throughput(w), label='VISDA', c='k', ls='--') ax.set(xlabel='Wavelength [microns]', ylabel=f\"Throughput [Fractional]\") plt.legend() Out[6]: <pre>&lt;matplotlib.legend.Legend at 0x13d3e4a90&gt;</pre> <p><code>pandora-sat</code> also includes a grid of phoenix models that you can use to model stars.</p> In\u00a0[7]: Copied! <pre>wav, sed = ps.utils.SED(5777, jmag=14)\n</pre> wav, sed = ps.utils.SED(5777, jmag=14) In\u00a0[8]: Copied! <pre>fig, ax = plt.subplots()\nax.plot(wav, sed)\nax.set(xlabel=f\"Wavelength {wav.unit.to_string('latex')}\", ylabel=f\"SED {sed.unit.to_string('latex')}\");\n</pre> fig, ax = plt.subplots() ax.plot(wav, sed) ax.set(xlabel=f\"Wavelength {wav.unit.to_string('latex')}\", ylabel=f\"SED {sed.unit.to_string('latex')}\"); <p>We can calculate the flux from this SED by multiplying by the sensitivity of the instrument, and then integrating across wavelength.</p> <p>!!! note \"Flux vs. Flux density\"</p> <pre><code>The SED of a star represents flux density, how much flux is emitted per wavelength element. We convert this to a flux by integrating over wavelength. In our case flux can have units of electrons per second, or ergs per second per square centimeter.</code></pre> In\u00a0[9]: Copied! <pre>flux = np.trapz((sed * visda.sensitivity(wav)), wav)\nflux\n</pre> flux = np.trapz((sed * visda.sensitivity(wav)), wav) flux Out[9]:  $2663.3141 \\; \\mathrm{\\frac{e^{-}}{s}}$  <p>This is the signal we expect for a 14th magnitude sun like star. We can use this to estimate the SNR for a source on the visible channel. Let's assume we want to know the signal to noise for this source after integrating for 2 minutes.</p> In\u00a0[10]: Copied! <pre>time = 120 * u.second\n</pre> time = 120 * u.second <p>This corresponds to a number of integrations. For the visible channel this is</p> In\u00a0[11]: Copied! <pre>nints = time/visda.integration_time\n</pre> nints = time/visda.integration_time <p>We assume the source is recorded on a few pixels. You can use <code>pandora-psf</code> to understand how many pixels the source falls on, but for this simple test let's assume the PSF is ~five pixels. To get a more realistic SNR calculation, we would need to use <code>pandora-psf</code> or <code>pandora-sim</code> but this will give us a ball park.</p> In\u00a0[12]: Copied! <pre>npixels = 5 * u.pixel\n</pre> npixels = 5 * u.pixel <p>We can then include all the noise terms that we want to model. For the visible detector this is the background rate, and the dark current rate. We also include the Poisson noise from the source.</p> In\u00a0[13]: Copied! <pre>rate_noise = (npixels * visda.background_rate) * time + (npixels * visda.dark_rate) * time \nrate_noise +=  ((flux.value**0.5) * flux.unit) * time\n</pre> rate_noise = (npixels * visda.background_rate) * time + (npixels * visda.dark_rate) * time  rate_noise +=  ((flux.value**0.5) * flux.unit) * time <p>We also need to model the read noise, which applies to every integration.</p> In\u00a0[14]: Copied! <pre>read_noise = (visda.read_noise * npixels) * nints\n</pre> read_noise = (visda.read_noise * npixels) * nints <p>We can then add these and calculate the signal to noise ratio.</p> In\u00a0[15]: Copied! <pre>noise = (rate_noise**2 + read_noise**2)**0.5\nSNR = (flux * time)/noise\n</pre> noise = (rate_noise**2 + read_noise**2)**0.5 SNR = (flux * time)/noise In\u00a0[16]: Copied! <pre>SNR\n</pre> SNR Out[16]:  $34.842756 \\; \\mathrm{}$  <p>Now we know given our assumptions we will detect this source on the visible channel with an SNR of ~35 in 2 minutes of integrations.</p> <p><code>pandora-sat</code> provides a Vega mag zeropoint for the detector, and it's midpoint</p> In\u00a0[17]: Copied! <pre>visda.zeropoint\n</pre> visda.zeropoint Out[17]:  $3.7767034 \\times 10^{-9} \\; \\mathrm{\\frac{erg}{\\mathring{A}\\,s\\,cm^{2}}}$  In\u00a0[18]: Copied! <pre>visda.midpoint\n</pre> visda.midpoint Out[18]:  $0.55825599 \\; \\mathrm{\\mu m}$  <p>The zeropoint converts flux to magnitude in the Pandora bandpass.</p> In\u00a0[19]: Copied! <pre>flux = np.trapz((sed * visda.sensitivity(wav)), wav)\nflux\n</pre> flux = np.trapz((sed * visda.sensitivity(wav)), wav) flux Out[19]:  $2663.3141 \\; \\mathrm{\\frac{e^{-}}{s}}$  In\u00a0[20]: Copied! <pre>visda.flux_to_mag(flux)\n</pre> visda.flux_to_mag(flux) Out[20]:  $15.276524 \\; \\mathrm{}$  <p>Here we have converted a flux in electrons per second to a magnitude. We can also convert a flux density which represents the average flux density in the bandpass to a magnitude:</p> In\u00a0[21]: Copied! <pre>normalized_sensitivity = visda.sensitivity(wav)/np.trapz(visda.sensitivity(wav), wav)\n</pre> normalized_sensitivity = visda.sensitivity(wav)/np.trapz(visda.sensitivity(wav), wav) In\u00a0[22]: Copied! <pre>avg_flux_density = np.trapz((sed * normalized_sensitivity), wav)\navg_flux_density\n</pre> avg_flux_density = np.trapz((sed * normalized_sensitivity), wav) avg_flux_density Out[22]:  $2.9274888 \\times 10^{-15} \\; \\mathrm{\\frac{erg}{\\mathring{A}\\,s\\,cm^{2}}}$  <p>Below I plot the SED for the star and overlay the normalized sensitivity of the instrument. You can see that the average flux density the average SED through the sensitivity of the instrument.</p> In\u00a0[23]: Copied! <pre>fig, ax1 = plt.subplots()\n\nax1.plot(wav, sed, label='Target SED')\nax1.scatter(visda.midpoint.to(wav.unit),\n            avg_flux_density,\n            c='r', \n            s=100, \n            zorder=10, \n            label='Flux Through Instrument Sensitivity')\n\nax1.set_xlabel(f\"Wavelength {wav.unit.to_string('latex')}\")\nax1.set_ylabel(f\"Flux Density {sed.unit.to_string('latex')}\")\n\nax2 = ax1.twinx()\n# Plot normalized_sensitivity on the new y-axis\nax2.plot(wav, normalized_sensitivity, label='Normalized Sensitivity [1/Angstrom]', c='gray')\nax2.set_ylabel(\"Normalized Sensitivity\")\nax2.spines[\"right\"].set_color(\"gray\")\nax2.spines['right'].set_visible(True)\nax2.tick_params(axis='y', colors=\"gray\")\nax2.yaxis.label.set_color(\"gray\")\n\nlines1, labels1 = ax1.get_legend_handles_labels()\nlines2, labels2 = ax2.get_legend_handles_labels()\nax1.legend(lines1 + lines2, labels1 + labels2, loc='best')\n\nplt.show()\n</pre> fig, ax1 = plt.subplots()  ax1.plot(wav, sed, label='Target SED') ax1.scatter(visda.midpoint.to(wav.unit),             avg_flux_density,             c='r',              s=100,              zorder=10,              label='Flux Through Instrument Sensitivity')  ax1.set_xlabel(f\"Wavelength {wav.unit.to_string('latex')}\") ax1.set_ylabel(f\"Flux Density {sed.unit.to_string('latex')}\")  ax2 = ax1.twinx() # Plot normalized_sensitivity on the new y-axis ax2.plot(wav, normalized_sensitivity, label='Normalized Sensitivity [1/Angstrom]', c='gray') ax2.set_ylabel(\"Normalized Sensitivity\") ax2.spines[\"right\"].set_color(\"gray\") ax2.spines['right'].set_visible(True) ax2.tick_params(axis='y', colors=\"gray\") ax2.yaxis.label.set_color(\"gray\")  lines1, labels1 = ax1.get_legend_handles_labels() lines2, labels2 = ax2.get_legend_handles_labels() ax1.legend(lines1 + lines2, labels1 + labels2, loc='best')  plt.show() <p>We can convert this into a magnitude inside the Pandora band</p> In\u00a0[24]: Copied! <pre>visda.average_flux_density_to_mag(avg_flux_density)\n</pre> visda.average_flux_density_to_mag(avg_flux_density) Out[24]:  $15.276544 \\; \\mathrm{}$  <p>Alternatively we can convert a magnitude to an average flux density estimate</p> In\u00a0[25]: Copied! <pre>visda.mag_to_average_flux_density(15.27)\n</pre> visda.mag_to_average_flux_density(15.27) Out[25]:  $2679.3652 \\; \\mathrm{\\frac{e^{-}}{s}}$  <p>Similarly you can convert flux to magnitude, and magnitude to flux</p> In\u00a0[26]: Copied! <pre>visda.mag_to_flux(15.27)\n</pre> visda.mag_to_flux(15.27) Out[26]:  $2679.3652 \\; \\mathrm{\\frac{e^{-}}{s}}$  In\u00a0[27]: Copied! <pre>visda.flux_to_mag(2679*u.electron/u.second)\n</pre> visda.flux_to_mag(2679*u.electron/u.second) Out[27]:  $15.270148 \\; \\mathrm{}$  <p>Using the above techniques, we can calculate this for a range of magnitudes and times.</p> In\u00a0[28]: Copied! <pre>fig, ax = plt.subplots()\nmags = np.arange(10, 20, 0.5)\nnpixels = 5 * u.pixel\nfor time in np.asarray([2, 10, 60, 120])*u.minute:\n    nints = time.to(u.second)/visda.integration_time\n    flux = visda.mag_to_flux(mags)* time.to(u.second)\n    rate_noise = (flux.value**0.5) * flux.unit\n    rate_noise += npixels * visda.background_rate * time.to(u.second)\n    rate_noise += npixels * visda.dark_rate * time.to(u.second)\n    read_noise = (visda.read_noise * npixels) * nints\n    noise = (rate_noise**2 + read_noise**2)**0.5\n    SNR = (flux)/noise\n    ax.plot(mags, SNR, label=time.to_string())\nax.set(xlabel='Pandora Magnitude', ylabel='SNR')\nax.legend()\n</pre> fig, ax = plt.subplots() mags = np.arange(10, 20, 0.5) npixels = 5 * u.pixel for time in np.asarray([2, 10, 60, 120])*u.minute:     nints = time.to(u.second)/visda.integration_time     flux = visda.mag_to_flux(mags)* time.to(u.second)     rate_noise = (flux.value**0.5) * flux.unit     rate_noise += npixels * visda.background_rate * time.to(u.second)     rate_noise += npixels * visda.dark_rate * time.to(u.second)     read_noise = (visda.read_noise * npixels) * nints     noise = (rate_noise**2 + read_noise**2)**0.5     SNR = (flux)/noise     ax.plot(mags, SNR, label=time.to_string()) ax.set(xlabel='Pandora Magnitude', ylabel='SNR') ax.legend() Out[28]: <pre>&lt;matplotlib.legend.Legend at 0x13ec79eb0&gt;</pre> <p>This is the SNR for a given Pandora magnitude. Remember you can convert your SED to a Pandora magnitude by integrating. If, for example, you only know the v band magnitude of the target, you will need to create an SED with units of <code>erg / (Angstrom cm^2 s)</code> or equivalent and then integrate through the Pandora sensitivity curve. You can create your SED in any fashion, and then find the Pandora magnitude:</p> In\u00a0[29]: Copied! <pre>wav = np.linspace(0.1, 3, 10000) *u.micron\nsed = 1e-13 * wav.value**2 * (u.erg / u.AA / u.s / u.cm**2)\nfig, ax = plt.subplots()\nax.plot(wav, sed)\nax.set(xlabel=f\"Wavelength {wav.unit.to_string('latex')}\", ylabel=f\"SED {sed.unit.to_string('latex')}\");\n</pre> wav = np.linspace(0.1, 3, 10000) *u.micron sed = 1e-13 * wav.value**2 * (u.erg / u.AA / u.s / u.cm**2) fig, ax = plt.subplots() ax.plot(wav, sed) ax.set(xlabel=f\"Wavelength {wav.unit.to_string('latex')}\", ylabel=f\"SED {sed.unit.to_string('latex')}\"); In\u00a0[30]: Copied! <pre>flux = np.trapz(sed * visda.sensitivity(wav), wav).to(u.electron/u.second)\nvisda.flux_to_mag(flux)\n</pre> flux = np.trapz(sed * visda.sensitivity(wav), wav).to(u.electron/u.second) visda.flux_to_mag(flux) Out[30]:  $12.680273 \\; \\mathrm{}$  <p>Here I have made an SED that is unphysical, and estimated the magnitude. Given our plot above, we expect such a source to be observable by Pandora with an SNR ~1000.</p> In\u00a0[\u00a0]: Copied! <pre>\n</pre>"},{"location":"intro-to-pandorasat/#introduction","title":"Introduction\u00b6","text":""},{"location":"intro-to-pandorasat/#calculating-snr","title":"Calculating SNR\u00b6","text":""},{"location":"intro-to-pandorasat/#calculating-magnitude","title":"Calculating Magnitude\u00b6","text":""},{"location":"intro-to-pandorasat/#calculating-snr-vs-magnitude","title":"Calculating SNR vs magnitude\u00b6","text":""},{"location":"irdetector/","title":"Documentation for <code>NIRDetector</code>","text":"<p>The <code>NIRDetector</code> class shows you what to expect from the Near IR side of Pandora. The key information on the detector is given below.</p> <p></p> NIRDA Detector Size (2048, 2048) Subarray Size (400, 80) Pixel Scale 1.19 \\(\\mathrm{\\frac{{}^{\\prime\\prime}}{pix}}\\) Pixel Size 18.0 \\(\\mathrm{\\frac{\\mu m}{pix}}\\) Dark Noise 1.0 \\(\\mathrm{\\frac{e^{-}}{pix\\,s}}\\) Wavelength Midpoint 1.30 \\(\\mathrm{\\mu m}\\) Pixel Read Time 1.0e-05 \\(\\mathrm{\\frac{s}{pix}}\\) Zeropoint 3.126e-10\\(\\mathrm{\\frac{erg}{A\\,s\\,cm^{2}}}\\) R @ 1.3\\(\\mu m\\) 65"},{"location":"irdetector/#api-documentation-for-pandorasatnirdetector","title":"API Documentation for <code>pandorasat.NIRDetector</code>","text":"<p>               Bases: <code>DetectorMixins</code></p> <p>Holds information on the Pandora IR detector</p>"},{"location":"irdetector/#pandorasat.irdetector.NIRDetector.bias","title":"<code>bias</code>  <code>property</code>","text":"<p>NIRDA detector bias</p>"},{"location":"irdetector/#pandorasat.irdetector.NIRDetector.bias_uncertainty","title":"<code>bias_uncertainty</code>  <code>property</code>","text":"<p>Uncertainty in NIRDA detector bias. Every integration has a different bias.</p>"},{"location":"irdetector/#pandorasat.irdetector.NIRDetector.bits_per_pixel","title":"<code>bits_per_pixel</code>  <code>property</code>","text":"<p>Number of bits per pixel</p>"},{"location":"irdetector/#pandorasat.irdetector.NIRDetector.correlated_double_sampling_read_noise","title":"<code>correlated_double_sampling_read_noise</code>  <code>property</code>","text":"<p>This is the read noise obtained when differencing two images.</p>"},{"location":"irdetector/#pandorasat.irdetector.NIRDetector.dark_rate","title":"<code>dark_rate</code>  <code>property</code>","text":"<p>Dark signal rate, detector only, no thermal</p>"},{"location":"irdetector/#pandorasat.irdetector.NIRDetector.gain","title":"<code>gain</code>  <code>property</code>","text":"<p>detector gain</p>"},{"location":"irdetector/#pandorasat.irdetector.NIRDetector.midpoint","title":"<code>midpoint</code>  <code>property</code>","text":"<p>Mid point of the sensitivity function</p>"},{"location":"irdetector/#pandorasat.irdetector.NIRDetector.naxis1","title":"<code>naxis1</code>  <code>property</code>","text":"<p>WCS's are COLUMN major, so naxis1 is the number of columns</p>"},{"location":"irdetector/#pandorasat.irdetector.NIRDetector.naxis2","title":"<code>naxis2</code>  <code>property</code>","text":"<p>WCS's are COLUMN major, so naxis2 is the number of rows</p>"},{"location":"irdetector/#pandorasat.irdetector.NIRDetector.non_linearity","title":"<code>non_linearity</code>  <code>property</code>","text":"<p>NIRDA non linearity</p>"},{"location":"irdetector/#pandorasat.irdetector.NIRDetector.pixel_read_time","title":"<code>pixel_read_time</code>  <code>property</code>","text":"<p>Pixel read time</p>"},{"location":"irdetector/#pandorasat.irdetector.NIRDetector.pixel_scale","title":"<code>pixel_scale</code>  <code>property</code>","text":"<p>Pixel scale of the detector</p>"},{"location":"irdetector/#pandorasat.irdetector.NIRDetector.pixel_size","title":"<code>pixel_size</code>  <code>property</code>","text":"<p>Size of a pixel</p>"},{"location":"irdetector/#pandorasat.irdetector.NIRDetector.read_noise","title":"<code>read_noise</code>  <code>property</code>","text":"<p>Read noise</p>"},{"location":"irdetector/#pandorasat.irdetector.NIRDetector.saturation_limit","title":"<code>saturation_limit</code>  <code>property</code>","text":"<p>NIRDA saturation limit. Bias contributes to saturation.</p>"},{"location":"irdetector/#pandorasat.irdetector.NIRDetector.shape","title":"<code>shape</code>  <code>property</code>","text":"<p>Shape of the detector in pixels</p>"},{"location":"irdetector/#pandorasat.irdetector.NIRDetector.stray_light_rate","title":"<code>stray_light_rate</code>  <code>property</code>","text":"<p>Stray light rate</p>"},{"location":"irdetector/#pandorasat.irdetector.NIRDetector.subarray_size","title":"<code>subarray_size</code>  <code>property</code>","text":"<p>Size of standard subarray</p>"},{"location":"irdetector/#pandorasat.irdetector.NIRDetector.thermal_background_rate","title":"<code>thermal_background_rate</code>  <code>property</code>","text":"<p>NIRDA thermal background rate</p>"},{"location":"irdetector/#pandorasat.irdetector.NIRDetector.zodiacal_background_rate","title":"<code>zodiacal_background_rate</code>  <code>property</code>","text":"<p>Zodiacal light background rate</p>"},{"location":"irdetector/#pandorasat.irdetector.NIRDetector.apply_gain","title":"<code>apply_gain(values)</code>","text":"<p>Applies a single gain value</p>"},{"location":"irdetector/#pandorasat.irdetector.NIRDetector.average_flux_density_to_mag","title":"<code>average_flux_density_to_mag(average_flux_density)</code>","text":"<p>Convert average flux density to magnitude based on the zeropoint of the detector</p>"},{"location":"irdetector/#pandorasat.irdetector.NIRDetector.estimate_zeropoint","title":"<code>estimate_zeropoint()</code>","text":"<p>Use Vega SED to estimate the zeropoint of the detector</p>"},{"location":"irdetector/#pandorasat.irdetector.NIRDetector.flux_to_mag","title":"<code>flux_to_mag(flux)</code>","text":"<p>Convert flux to magnitude based on the zeropoint of the detector</p>"},{"location":"irdetector/#pandorasat.irdetector.NIRDetector.frame_time","title":"<code>frame_time(array_size=None)</code>","text":"<p>Time to read out one frame of the subarray</p>"},{"location":"irdetector/#pandorasat.irdetector.NIRDetector.get_wcs","title":"<code>get_wcs(ra, dec, theta=u.Quantity(0, unit='degree'))</code>","text":"<p>Returns an astropy.wcs.WCS object</p>"},{"location":"irdetector/#pandorasat.irdetector.NIRDetector.mag_to_average_flux_density","title":"<code>mag_to_average_flux_density(mag)</code>","text":"<p>Convert magnitude to average flux density based on the zeropoint of the detector</p>"},{"location":"irdetector/#pandorasat.irdetector.NIRDetector.mag_to_flux","title":"<code>mag_to_flux(mag)</code>","text":"<p>Convert magnitude to flux based on the zeropoint of the detector</p>"},{"location":"irdetector/#pandorasat.irdetector.NIRDetector.plot_sensitivity","title":"<code>plot_sensitivity(ax=None)</code>","text":"<p>Plot the sensitivity of the detector as a function of wavelength</p>"},{"location":"irdetector/#pandorasat.irdetector.NIRDetector.qe","title":"<code>qe(wavelength)</code>","text":"<p>Calculate the quantum efficiency of the detector.</p>"},{"location":"irdetector/#pandorasat.irdetector.NIRDetector.qe--parameters","title":"Parameters","text":"<p>wavelength : npt.NDArray     Wavelength in microns as <code>astropy.unit</code></p>"},{"location":"irdetector/#pandorasat.irdetector.NIRDetector.qe--returns","title":"Returns","text":"<p>qe : npt.NDArray     Array of the quantum efficiency of the detector</p>"},{"location":"irdetector/#pandorasat.irdetector.NIRDetector.sensitivity","title":"<code>sensitivity(wavelength)</code>","text":"<p>Calulate the sensitivity of the detector.</p>"},{"location":"irdetector/#pandorasat.irdetector.NIRDetector.sensitivity--parameters","title":"Parameters","text":"<p>wavelength : npt.NDArray     Wavelength in microns as <code>astropy.unit</code></p>"},{"location":"irdetector/#pandorasat.irdetector.NIRDetector.sensitivity--returns","title":"Returns","text":"<p>sensitivity : npt.NDArray     Array of the sensitivity of the detector</p>"},{"location":"irdetector/#pandorasat.irdetector.NIRDetector.throughput","title":"<code>throughput(wavelength)</code>","text":"<p>Optical throughput at the specified wavelength(s)</p>"},{"location":"orbit/","title":"Documentation for <code>Orbit</code>","text":"<p>The <code>Orbit</code> class contains basic information about Pandora's orbit</p>"},{"location":"orbit/#api-documentation-for-pandorasatorbit","title":"API Documentation for <code>pandorasat.Orbit</code>","text":"<p>Holds basic metadata on the orbit of Pandora</p>"},{"location":"pandorasat/","title":"Documentation for <code>PandoraSat</code>","text":"<p>               Bases: <code>object</code></p> <p>Holds information and methods for the full Pandora system.</p> <p>Parameters:</p> Name Type Description Default <code>NIRDA</code> <code>IRDetector</code> <p>Class of the NIRDA properties</p> required <code>VISDA</code> <code>IRDetector</code> <p>Class of the VISDA properties</p> required <code>Optics</code> <code>IRDetector</code> <p>Class of the Optics properties</p> required <code>Orbit</code> <code>IRDetector</code> <p>Class of the Orbit properties</p> required"},{"location":"visibledetector/","title":"Documentation for <code>VISDA</code>","text":"<p>The <code>VisibleDetector</code> class shows you what to expect from the Visible side of Pandora. The key information on the detector is given below.</p> <p></p> VISDA Detector Size (2048, 2048) Pixel Scale 0.78 \\(\\mathrm{\\frac{{}^{\\prime\\prime}}{pix}}\\) Pixel Size 6.5 \\(\\mathrm{\\frac{\\mu m}{pix}}\\) Read Noise 1.5 \\(\\mathrm{\\frac{e^{-}}{pix}}\\) Dark Noise 1.0 \\(\\mathrm{\\frac{e^{-}}{pix\\,s}}\\) Bias 100.0 \\(\\mathrm{DN}\\) Wavelength Midpoint 0.56 \\(\\mathrm{\\mu m}\\) Integration Time 0.2 \\(\\mathrm{s}\\) Zeropoint 3.765e-09\\(\\mathrm{\\frac{erg}{A\\,s\\,cm^{2}}}\\)"},{"location":"visibledetector/#api-documentation-for-pandorasatvisibledetector","title":"API Documentation for <code>pandorasat.VisibleDetector</code>","text":"<p>               Bases: <code>DetectorMixins</code></p> <p>Holds information on the Pandora Visible Detector</p>"},{"location":"visibledetector/#pandorasat.visibledetector.VisibleDetector.background_rate","title":"<code>background_rate</code>  <code>property</code>","text":"<p>Detector background rate</p>"},{"location":"visibledetector/#pandorasat.visibledetector.VisibleDetector.bias","title":"<code>bias</code>  <code>property</code>","text":"<p>Detector bias</p>"},{"location":"visibledetector/#pandorasat.visibledetector.VisibleDetector.bits_per_pixel","title":"<code>bits_per_pixel</code>  <code>property</code>","text":"<p>Number of bits per pixel</p>"},{"location":"visibledetector/#pandorasat.visibledetector.VisibleDetector.dark_rate","title":"<code>dark_rate</code>  <code>property</code>","text":"<p>Dark Noise</p>"},{"location":"visibledetector/#pandorasat.visibledetector.VisibleDetector.fieldstop_radius","title":"<code>fieldstop_radius</code>  <code>property</code>","text":"<p>Radius of the fieldstop</p>"},{"location":"visibledetector/#pandorasat.visibledetector.VisibleDetector.integration_time","title":"<code>integration_time</code>  <code>property</code>","text":"<p>Integration time</p>"},{"location":"visibledetector/#pandorasat.visibledetector.VisibleDetector.midpoint","title":"<code>midpoint</code>  <code>property</code>","text":"<p>Mid point of the sensitivity function</p>"},{"location":"visibledetector/#pandorasat.visibledetector.VisibleDetector.naxis1","title":"<code>naxis1</code>  <code>property</code>","text":"<p>WCS's are COLUMN major, so naxis1 is the number of columns</p>"},{"location":"visibledetector/#pandorasat.visibledetector.VisibleDetector.naxis2","title":"<code>naxis2</code>  <code>property</code>","text":"<p>WCS's are COLUMN major, so naxis2 is the number of rows</p>"},{"location":"visibledetector/#pandorasat.visibledetector.VisibleDetector.pixel_scale","title":"<code>pixel_scale</code>  <code>property</code>","text":"<p>Pixel scale of the detector</p>"},{"location":"visibledetector/#pandorasat.visibledetector.VisibleDetector.pixel_size","title":"<code>pixel_size</code>  <code>property</code>","text":"<p>Size of a pixel</p>"},{"location":"visibledetector/#pandorasat.visibledetector.VisibleDetector.read_noise","title":"<code>read_noise</code>  <code>property</code>","text":"<p>Read Noise</p>"},{"location":"visibledetector/#pandorasat.visibledetector.VisibleDetector.shape","title":"<code>shape</code>  <code>property</code>","text":"<p>Shape of the detector in pixels</p>"},{"location":"visibledetector/#pandorasat.visibledetector.VisibleDetector.apply_gain","title":"<code>apply_gain(values)</code>","text":"<p>Applies a piecewise gain function</p>"},{"location":"visibledetector/#pandorasat.visibledetector.VisibleDetector.average_flux_density_to_mag","title":"<code>average_flux_density_to_mag(average_flux_density)</code>","text":"<p>Convert average flux density to magnitude based on the zeropoint of the detector</p>"},{"location":"visibledetector/#pandorasat.visibledetector.VisibleDetector.estimate_zeropoint","title":"<code>estimate_zeropoint()</code>","text":"<p>Use Vega SED to estimate the zeropoint of the detector</p>"},{"location":"visibledetector/#pandorasat.visibledetector.VisibleDetector.flux_to_mag","title":"<code>flux_to_mag(flux)</code>","text":"<p>Convert flux to magnitude based on the zeropoint of the detector</p>"},{"location":"visibledetector/#pandorasat.visibledetector.VisibleDetector.get_wcs","title":"<code>get_wcs(ra, dec, theta=u.Quantity(0, unit='degree'), crpix1=1024, crpix2=1024, order=3)</code>","text":"<p>Returns an astropy.wcs.WCS object</p>"},{"location":"visibledetector/#pandorasat.visibledetector.VisibleDetector.mag_to_average_flux_density","title":"<code>mag_to_average_flux_density(mag)</code>","text":"<p>Convert magnitude to average flux density based on the zeropoint of the detector</p>"},{"location":"visibledetector/#pandorasat.visibledetector.VisibleDetector.mag_to_flux","title":"<code>mag_to_flux(mag)</code>","text":"<p>Convert magnitude to flux based on the zeropoint of the detector</p>"},{"location":"visibledetector/#pandorasat.visibledetector.VisibleDetector.plot_sensitivity","title":"<code>plot_sensitivity(ax=None)</code>","text":"<p>Plot the sensitivity of the detector as a function of wavelength</p>"},{"location":"visibledetector/#pandorasat.visibledetector.VisibleDetector.qe","title":"<code>qe(wavelength)</code>","text":"<p>Calculate the quantum efficiency of the detector.</p>"},{"location":"visibledetector/#pandorasat.visibledetector.VisibleDetector.qe--parameters","title":"Parameters","text":"<p>wavelength : npt.NDArray     Wavelength in microns as <code>astropy.unit</code></p>"},{"location":"visibledetector/#pandorasat.visibledetector.VisibleDetector.qe--returns","title":"Returns","text":"<p>qe : npt.NDArray     Array of the quantum efficiency of the detector</p>"},{"location":"visibledetector/#pandorasat.visibledetector.VisibleDetector.sensitivity","title":"<code>sensitivity(wavelength)</code>","text":"<p>Calulate the sensitivity of the detector.</p>"},{"location":"visibledetector/#pandorasat.visibledetector.VisibleDetector.sensitivity--parameters","title":"Parameters","text":"<p>wavelength : npt.NDArray     Wavelength in microns as <code>astropy.unit</code></p>"},{"location":"visibledetector/#pandorasat.visibledetector.VisibleDetector.sensitivity--returns","title":"Returns","text":"<p>sensitivity : npt.NDArray     Array of the sensitivity of the detector</p>"},{"location":"visibledetector/#pandorasat.visibledetector.VisibleDetector.throughput","title":"<code>throughput(wavelength)</code>","text":"<p>Optical throughput at the specified wavelength(s)</p>"},{"location":"info/NIRDA/","title":"NIRDA","text":"NIRDA Detector Size (2048, 2048) Subarray Size (400, 80) Pixel Scale 1.19 \\(\\mathrm{\\frac{{}^{\\prime\\prime}}{pix}}\\) Pixel Size 18.0 \\(\\mathrm{\\frac{\\mu m}{pix}}\\) Dark Noise 1.0 \\(\\mathrm{\\frac{e^{-}}{pix\\,s}}\\) Wavelength Midpoint 1.30 \\(\\mathrm{\\mu m}\\) Pixel Read Time 1.0e-05 \\(\\mathrm{\\frac{s}{pix}}\\) Zeropoint 3.126e-10\\(\\mathrm{\\frac{erg}{A\\,s\\,cm^{2}}}\\) R @ 1.3\\(\\mu m\\) 65"},{"location":"info/VISDA/","title":"VISDA","text":"VISDA Detector Size (2048, 2048) Pixel Scale 0.78 \\(\\mathrm{\\frac{{}^{\\prime\\prime}}{pix}}\\) Pixel Size 6.5 \\(\\mathrm{\\frac{\\mu m}{pix}}\\) Read Noise 1.5 \\(\\mathrm{\\frac{e^{-}}{pix}}\\) Dark Noise 1.0 \\(\\mathrm{\\frac{e^{-}}{pix\\,s}}\\) Bias 100.0 \\(\\mathrm{DN}\\) Wavelength Midpoint 0.56 \\(\\mathrm{\\mu m}\\) Integration Time 0.2 \\(\\mathrm{s}\\) Zeropoint 3.765e-09\\(\\mathrm{\\frac{erg}{A\\,s\\,cm^{2}}}\\)"}]}